<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Zoyi ZT219/ Aneng AN870 EEPROM Editor (forked by pawol)</title>
    <style type="text/css">
#main_container {
    width: 900px;
    padding: 1em;
    border: 1px solid black;
    margin: auto;
}

#section_load_save {
    padding: .4em;
    border: 1px solid black;
}

#logs_container {
    background-color: blanchedalmond;
    border: 1px solid black;
    width: 100%;
    height: 150px;
    overflow: auto;
    display: none;
}

#logs p {
    margin: 0;
}

#hex_dumps {
    column-count: 2;
    height: 300px;
    width: 875px;
    margin: 1em;
}

#hex_dumps h3 {
    margin: 0;
    font-family: monospace;
}

.hex_dump {
    font-family: monospace;
    white-space: pre;

}

.hex_dump .hex_container_grid {
    display: grid;
}

.hex_dump .hexrange:hover {
    background-color: #c30f0f !important;
    color: white;
    cursor: pointer;
}

.hex_dump .hexrange.unused:hover {
    background-color: #aaaaaa !important;
    cursor: default;
}

.dump_container {
    display: block;
    width: fit-content;
}

.dump_container .column_row_common {
    grid-column: 1;
    grid-row: 1;
    background-color: #CCCCCC;
}
.dump_container .column_offset {
    grid-column: 2;
    grid-row: 1;
    background-color: #CCCCCC;
    color: #666666;
}

.dump_container .row_offset {
    grid-column: 1;
    grid-row: 2;
    white-space: pre-wrap;
    padding-right: .5em;
    background-color: #CCCCCC;
    color: #666666;
}

.dump_container .dump_content {
    grid-column: 2;
    grid-row: 2;
}

#editor_container {
    height: 400px;
    overflow: auto;
    border: 2px solid steelblue;
    padding: .5em;
}

#editor_container #editors p {
    border-bottom: 1px solid black;
    margin: 0;
    padding-bottom: .5em;
    padding-top: .5em;
}

#editor_container h3 {
    margin: 0px;
}

.modified {
    color: red;
    font-weight: bold;
}

#hexhover {
    position: fixed;
    border: 1px solid black;
    min-width: 70px;
    min-height: 1em;
    top: 0px;
    left: 0px;
    background-color: white;
    display: none;
    padding: 3px;
    font-family: monospace;
}

.meterModes .unused {
    display: none;
}

.blink_three_times {
    animation: blinker 0.2s cubic-bezier(.5, 0, 1, 1) 4 alternate;
  }
@keyframes blinker { to { background-color: coral; } }

.bibliography {
    font-size: 75%;
}

#main_container h1 {
    text-align: center;
}

#main_container h1 a {
    text-decoration: underline;
}

#main_container h1 a:hover {
    color: red !important;
}

#main_container h1 a:visited {
    color: inherit;
}
    </style>
   </head>
  <body>
      <div id="main_container">
        <h1><a href="https://github.com/pawol/Zoyi-ZT219_Aneng-AN870_EEPROM_Editor">Zoyi ZT219/ Aneng AN870</a> v1.0 by (<a href="https://github.com/pawol">pawol</a>)</h1>
        <div class="bibliography">Sources:
            <a href="https://www.youtube.com/watch?v=Vj6b-clYTis">TheHWcave</a>
             | Kerrywong [<a href="http://www.kerrywong.com/2016/03/19/hacking-dtm0660l-based-multimeters/">1</a>]
                         [<a href="http://www.kerrywong.com/2016/04/03/dtm0660-datasheet-translated/">2</a>]
             | <a href="https://github.com/bdlow/UT210E">bdlow/UT210E</a>
             | <a href="https://www.eevblog.com/forum/testgear/a-look-at-the-uni-t-ut210e/">EEVblog</a>
             | kazus.ru [<a href="http://kazus.ru/forums/showpost.php?p=1034266&postcount=619">1</a>]
                        [<a href="http://kazus.ru/forums/showpost.php?p=1019418&postcount=427">2</a>]
                        [<a href="http://kazus.ru/forums/showpost.php?p=1010682&postcount=200">3</a>]
                        [<a href="http://kazus.ru/forums/showpost.php?p=1037277&postcount=663">4</a>]
			 |			[<a href="https://github.com/devydd">Devydd</a>]
             | Thank you for all the hard work doing research, creating write-ups and videos! This editor
            works for both DTM0660 and DM1106EN ASICs.
        </div>

        <div id="section_load_save">
            <span>Load EEPROM dump file(.bin): <input type="file" id="btnLoadEEPROM"/></span> |
            <button id="get_modified_dump" disabled>Save modified EEPROM file (.bin)</button>
        </div>

        <div id="hex_dumps">
            <div class="dump_container">
                <h3>Original data:</h3>
                <div id="original_hex_dump" class="hex_dump">(Load the EEPROM to see EEPROM map)</div>
            </div>
            <div class="dump_container">
                <h3>Modified data:</h3>
                <div id="modified_hex_dump" class="hex_dump">(Load the EEPROM to see EEPROM map)</div>
            </div>

            <div id="hexhover">
                <div class="range_description">50 mF calibration</div>
                <div class="offset_value_section"><strong>Offset</strong>: <span class="offset_value">0x????</span></div>
                <div class="org_value_section"><strong>Original</strong>: <span class="org_value">0x????</span></div>
                <div class="cur_value_section"><strong>&nbsp;Current</strong>: <span class="cur_value">0x????</span></div>
            </div>
        </div>

        <div id="editor_container">
            (EEPROM editor will show up after loading EEPROM dump)
        </div>

        <div id="logs_container">
            <h3>Logs:</h3>
            <div id="logs"></div>
        </div>
    </div>
    <script type="text/javascript">
'use strict';
(_=>{
const T_BYTE = 1;
const T_WORD = 2;

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------
// ============================== EEPROM-SPECIFIC CONFIGURATION ==============================
const EEPROM_size = 256;

const bin_ranges = [
    // 0x00 .. 0x0A - unknown
    {
        offset: 0x0B,
        len: T_WORD,
        default: 0x00E6,
        description: "Environment temperature (EEPROM address: 0x0B)",
        proc: "num",
        section_description: "Environment temperature [Celsius]."
    },
    {
        offset: 0x0D,
        len: T_BYTE,
        default: 0xC0,
        description: "Environment temperature default ADC value (byte 1) (EEPROM address: 0x0D)",
        proc: "num",
        section_description: "Environment temperature default ADC value (byte 1)."
    },
    {
        offset: 0x0E,
        len: T_BYTE,
        default: 0xEF,
        description: "Environment temperature default ADC value (byte 2) (EEPROM address: 0x0E)",
        proc: "num",
        section_description: "Environment temperature default ADC value (byte 2)."
    },
    {
        offset: 0x0F,
        len: T_BYTE,
        default: 0x03,
        description: "Environment temperature default ADC value (byte 3) (EEPROM address: 0x0F)",
        proc: "num",
        section_description: "Environment temperature default ADC value (byte 3)."
    },
    {
        offset: 0x10,
        len: T_WORD,
        default: 0x1710,
        description: "Range (EEPROM address: 0x10)",
        proc: "num",
        section_description: 'Full range counts (doesn\'t apply to capacitance). True meaning unknown (!). <ul><li><strong>ZT219/AN870 default</strong>: 5904 (0x1710).</li></ul>'
    },
    {
        offset: 0x12,
        len: T_WORD,
        default: 0x4E20,
        description: "Range switch upper threshold (EEPROM address: 0x12)",
        proc: "num",
        section_description: 'After exceeding this count value the meter switches to the next range (in auto-ranging mode) or shows the overload symbol OL (in manual mode). <br>To avoid switching between modes on borderline values, incorporate some hysteresis (+ ~10%) into this value. (Doesn\'t apply to capacitance) <ul><li><strong>ZT219/AN870 default</strong>: 20000 (0x4E20).</li></ul>'
    },
    {
        offset: 0x14,
        len: T_WORD,
        default: 0x0708,
        description: "Range switch lower threshold (EEPROM address: 0x14)",
        proc: "num",
        section_description: 'After going below this count the meter switches back to the previous range (in auto-ranging mode). No effect in manual mode.<br>To avoid switching between modes on borderline values, incorporate some hysteresis (- ~5%) into this value. (Doesn\'t apply to capacitance) <ul><li><strong>ZT219/AN870 default</strong>: 1800 (0x0708).</li></ul>'
    },
    {
        offset: 0x16,
        len: T_BYTE,
        default: 0x6E,
        description: "DC Over-voltage [V] (EEPROM address: 0x16)",
        proc: "num",
        section_description: 'DC Voltage OL value on 2000V range (unit *10V). <br><ul><li><strong>ZT219/AN870 default</strong>: 110 (0x6E).</li></ul>'
    },
    {
        offset: 0x17,
        len: T_BYTE,
        default: 0x50,
        description: "AC Over-voltage [V] (EEPROM address: 0x17)",
        proc: "num",
        section_description: 'AC Voltage OL value on 2000V range (unit *10V). <br><ul><li><strong>ZT219/AN870 default</strong>: 80 (0x50).</li></ul>'
    },
    {
        offset: 0x18,
        len: T_BYTE,
        default: 0x64,
        description: "DC warning-voltage [V] (EEPROM address: 0x18)",
        proc: "num",
        section_description: 'DC Voltage warning voltage on 2000V range (unit *10V). <br><ul><li><strong>ZT219/AN870 default</strong>: 100 (0x64).</li></ul>'
    },
    {
        offset: 0x19,
        len: T_BYTE,
        default: 0x4B,
        description: "AC warning-voltage [V] (EEPROM address: 0x19)",
        proc: "num",
        section_description: 'AC Voltage warning voltage on 2000V range (unit *10V). <br><ul><li><strong>ZT219/AN870 default</strong>: 75 (0x4B).</li></ul>'
    },
    {
        offset: 0x1A,
        len: T_BYTE,
        default: 0x3C,
        description: "μA current warning [μA]. Does not work as expected. (EEPROM address: 0x1A)",
        proc: "num",
        section_description: 'μA range warning current 2000uA (unit *100uA). <br><ul><li><strong>ZT219/AN870 default</strong>: 60 (0x3C).</li></ul>'
    },
    {
        offset: 0x1B,
        len: T_BYTE,
        default: 0x3C,
        description: "mA current warning [mA]. Does not work as expected. (EEPROM address: 0x1B)",
        proc: "num",
        section_description: 'mA range warning current 200mA (unit *100mA). <br><ul><li><strong>ZT219/AN870 default</strong>: 60 (0x3C).</li></ul>'
    },
    {
        offset: 0x1C,
        len: T_BYTE,
        default: 0x0A,
        description: "A current warning [A] (EEPROM address: 0x1C)",
        proc: "num",
        section_description: 'After exceeding this value in any of the current measurement modes the current warning is invoked (beeping?). <ul><li><strong>ZT219/AN870 default</strong>: 10 (0x0A).</li></ul>'
    },
    // 0x01D - unknown
    {
        offset: 0x1E,
        len: T_BYTE,
        default: 0x40,
        description: "NCV display (EEPROM address: 0x1E)",
        proc: "num",
        section_description: "NCV display symbol default is the G segment (bit0~6 corresponds to ABCDEFG segment). <br><ul><li><strong>ZT219/AN870 default</strong>: 64 (0x40).</li></ul>"
    },
    {
        offset: 0x20,
        len: T_WORD,
        default: 0x9999,
        description: "Amplifier parameter (EEPROM address: 0x20)",
        proc: "num",
        section_description: "Amplifier parameter."
    },
    {
        offset: 0x22,
        len: T_WORD,
        default: 0x8000,
        description: "500mV calibration (EEPROM address: 0x22)",
        proc: "num",
        section_description: "500mV calibration adjustment ratio."
    },
    {
        offset: 0x24,
        len: T_WORD,
        default: 0x0320,
        description: "NCV base number (EEPROM address: 0x24)",
        proc: "num",
        section_description: "NCV base number (10.0 mV). <br><ul><li><strong>ZT219/AN870 default</strong>: 800 (0x320).</li></ul>"
    },
    {
        offset: 0x26,
        len: T_WORD,
        default: 0x05DC,
        description: "NCV resolution (EEPROM address: 0x26)",
        proc: "num",
        section_description: "NCV resolution (15.0 mV). <br><ul><li><strong>ZT219/AN870 default</strong>: 1500 (0x05DC).</li></ul>"
    },
    {
        offset: 0x28,
        len: T_WORD,
        default: 0x8000,
        description: "AC 2V range compensation ratio (EEPROM address: 0x28)",
        proc: "num",
        section_description: "AC 2V range compensation ratio (frequency)."
    },
    {
        offset: 0x2A,
        len: T_WORD,
        default: 0x8000,
        description: "500 μA calibration (EEPROM address: 0x2A)",
        proc: "num",
        section_description: "500uA calibration adjustment ratio."
    },
    {
        offset: 0x2C,
        len: T_WORD,
        default: 0x8000,
        description: "50 mA calibration (EEPROM address: 0x2C)",
        proc: "num",
        section_description: "50mA calibration adjustment ratio."
    },
    {
        offset: 0x2E,
        len: T_WORD,
        default: 0x8000,
        description: "5 A calibration (EEPROM address: 0x2E)",
        proc: "num",
        section_description: "5A calibration adjustment ratio."
    },
    // 0x30..0x34 - unknown
    {
        offset: 0x35,
        len: T_BYTE,
        default: 0x09,
        description: "Ohm/Continuity/Diode (EEPROM address: 0x35)",
        proc: "num",
        section_description: "Ohm/Continuity/Diode (???). <br><ul><li><strong>ZT219/AN870 default</strong>: 9 (0x09).</li></ul>"
    },
    // 0x36..0x3A - unknown
    {
        offset: 0x3B,
        len: T_BYTE,
        default: 0x09,
        description: "Ohm/Continuity (EEPROM address: 0x3B)",
        proc: "num",
        section_description: "Ohm/Continuity (???). <br><ul><li><strong>ZT219/AN870 default</strong>: 9 (0x09).</li></ul>"
    },
    // 0x3C..0x3D - unknown
    {
        offset: 0x3E,
        len: T_BYTE,
        default: 0x09,
        description: "Ohm/Continuity (EEPROM address: 0x3E)",
        proc: "num",
        section_description: "Ohm/Continuity (???). <br><ul><li><strong>ZT219/AN870 default</strong>: 9 (0x09).</li></ul>"
    },
    // 0x3F - unknown
    {
        offset: 0x40,
        len: T_WORD,
        default: 0x0100,
        description: "AC 20mV (EEPROM address: 0x40)",
        proc: "num",
        section_description: "AC 20mV range noise to be subtracted (input signal is internally amplified). <br><ul><li><strong>ZT219/AN870 default</strong>: 256 (0x0100).</li></ul>"
    },
    {
        offset: 0x42,
        len: T_WORD,
        default: 0x0100,
        description: "AC 200mV (EEPROM address: 0x42)",
        proc: "num",
        section_description: "AC 200mV range noise to be subtracted (input signal is not amplified). <br><ul><li><strong>ZT219/AN870 default</strong>: 256 (0x0100).</li></ul>"
    },
    {
        offset: 0x44,
        len: T_WORD,
        default: 0x0700,
        description: "AC 200mV div (EEPROM address: 0x44)",
        proc: "num",
        section_description: "AC 200mV range noise to be subtracted (10M resistor divider, amplified). <br><ul><li><strong>ZT219/AN870 default</strong>: 1792 (0x700).</li></ul>"
    },
    {
        offset: 0x46,
        len: T_WORD,
        default: 0x0098,
        description: "AC 2V div (EEPROM address: 0x46)",
        proc: "num",
        section_description: "AC 2V range noise to be subtracted (10M resistor divider). <br><ul><li><strong>ZT219/AN870 default</strong>: 152 (0x0098).</li></ul>"
    },
    {
        offset: 0x48,
        len: T_WORD,
        default: 0x0064,
        description: "AC 20V div (EEPROM address: 0x48)",
        proc: "num",
        section_description: "AC 20V range noise to be subtracted (10M resistor divider). <br><ul><li><strong>ZT219/AN870 default</strong>: 100 (0x0064).</li></ul>"
    },
    {
        offset: 0x4A,
        len: T_WORD,
        default: 0x0064,
        description: "AC 200V div (EEPROM address: 0x4A)",
        proc: "num",
        section_description: "AC 200V range noise to be subtracted (10M resistor divider). <br><ul><li><strong>ZT219/AN870 default</strong>: 100 (0x0064).</li></ul>"
    },
    {
        offset: 0x4C,
        len: T_WORD,
        default: 0x0064,
        description: "AC 1000V div (EEPROM address: 0x4C)",
        proc: "num",
        section_description: "AC 1000V range noise to be subtracted (10M resistor divider). <br><ul><li><strong>ZT219/AN870 default</strong>: 100 (0x0064).</li></ul>"
    },
    // 0x4E..0x4F - unknown 0x0000
    {
        offset: 0x50,
        len: 0x10,
        default: null,
        description: "Calibration data for amps [A] (EEPROM address: 0x50)",
        proc: "cal",
        section_description: "Calibration data for amps - <strong>200A and 2000A range is not applicable for ZT219/AN870</strong>"
    },

    {
        offset: 0x60,
        len: T_WORD,
        default: 0x8000,
        description: "50kΩ calibration (EEPROM address: 0x60)",
        proc: "num",
        section_description: "50k resistor calibration adjustment ratio."
    },
    {
        offset: 0x62,
        len: T_WORD,
        default: 0x8000,
        description: "50 MΩ calibration (EEPROM address: 0x62)",
        proc: "num",
        section_description: "50M resistor calibration adjustment ratio."
    },
    // 0x64..0x66 - unknown
    {
        offset: 0x67,
        len: T_BYTE,
        default: 0x00,
        description: "Ohm/Continuity (EEPROM address: 0x67)",
        proc: "num",
        section_description: "Ohm/Continuity (???)."
    },
    // 0x68..0x6F - unknown

    {
        offset: 0x70,
        len: T_WORD,
        default: 0x8000,
        description: "500nF calibration (EEPROM address: 0x70)",
        proc: "num",
        section_description: "500nF capacitor calibration adjustment ratio."
    },
    {
        offset: 0x72,
        len: T_WORD,
        default: 0x8000,
        description: "50μF calibration (EEPROM address: 0x72)",
        proc: "num",
        section_description: "50μF capacitor calibration adjustment ratio."
    },
    {
        offset: 0x74,
        len: T_WORD,
        default: 0x8000,
        description: "500 μF calibration (EEPROM address: 0x74)",
        proc: "num",
        section_description: "500μF capacitor calibration adjustment ratio."
    },
    {
        offset: 0x76,
        len: T_WORD,
        default: 0x8000,
        description: "50mF calibration (EEPROM address: 0x76)",
        proc: "num",
        section_description: "50mF capacitor calibration adjustment ratio."
    },
    {
        offset: 0x78,
        len: T_WORD,
        default: 0x0118,
        description: "Calibration: capacitor baseline (EEPROM address: 0x78)",
        proc: "num",
        section_description: "Capacitor 9nF range base line to be subtracted (e.g. when no capacitor is connected, unit 0.001 nF)."
    },
    // 0x7A..0x7F - unknown (0x00 fill)

    {
        offset: 0x80,
        len: 0x40,
        default: null,
        description: "Measurement functionality (modes) setting (EEPROM address: 0x80)",
        proc: "func",
        section_description: 'Specifies sub-modes for each mode. Modes are selected using the dial (knob) on the from face fo the multimeter. For each mode the first sub-mode is selected by default. To cycle through the sub-modes available in the current mode, short-press the <span class="button">SELECT</span>. button. The sub-modes are cycled through in a loop (that is: sub-mode 1 -> sub-mode 2 -> sub-mode 3 -> sub-mode 4 -> sub-mode 1 -> ...).'
    },

    // 0xC0..0xE7 - unknown

    {
        offset: 0xE8,
        len: T_WORD,
        default: 0x8000,
        description: "Calibration: DC 200mV adj ratio (EEPROM address: 0xE8)",
        proc: "num",
        section_description: "DC 200mV range calibration adjustment ratio."
    },
    {
        offset: 0xEA,
        len: T_WORD,
        default: 0x8000,
        description: "Calibration: DC 2V adj ratio (EEPROM address: 0xEA)",
        proc: "num",
        section_description: "DC 2V range calibration adjustment ratio."
    },
    {
        offset: 0xEC,
        len: T_WORD,
        default: 0x8000,
        description: "Calibration: DC 20V adj ratio (EEPROM address: 0xEC)",
        proc: "num",
        section_description: "DC 20V range calibration adjustment ratio."
    },
    {
        offset: 0xEE,
        len: T_WORD,
        default: 0x8000,
        description: "Calibration: DC 200V adj ratio (EEPROM address: 0xEE)",
        proc: "num",
        section_description: "DC 200V range calibration adjustment ratio."
    },

    {
        offset: 0xF0,
        len: T_WORD,
        default: 0x8000,
        description: "Calibration: DC 1000V adj ratio (EEPROM address: 0xF0)",
        proc: "num",
        section_description: "DC 1000V range calibration adjustment ratio."
    },
    // 0xF2..0xF8 - unknown
    {
        offset: 0xF9,
        len: T_BYTE,
        default: 0xC7,
        description: "Config bitmap 1 (EEPROM address: 0xF9)",
        section_description: "",
        proc: "bitfield",
        bits: [{
                bitsNumber: [0],
                values: {
                    0: "no beep",
                    1: "beep"
                },
                desc: "1 NCV (PT1.2 is synchronized with the beeper)"
            },
            {
                bitsNumber: [1],
                values: {
                    0: "PT1.2=1",
                    1: "PT1.2=0"
                },
                desc: "PT1.2 state upon power on: 1: PT1.2=1, 0: PT1.2=0 (note, when PT1.2 used to synchronize with NCV state, it can only be set to 1)"
            },
            {
                bitsNumber: [3, 2],
                values: {
                    0: "3.3V",
                    1: "3.0V",
                    2: "2.8V",
                    3: "2.5V"
                },
                desc: "VLDC"
            },
            {
                bitsNumber: [5, 4],
                values: {
                    0: "3.6V",
                    1: "3.2V",
                    2: "2.8V",
                    3: "2.4V"
                },
                desc: "VDD"
            },
            {
                bitsNumber: [6],
                values: {
                    0: '?',
                    1: 'default'
                },
                desc: "reserved"
            },
            {
                bitsNumber: [7],
                values: {
                    0: '?',
                    1: 'default'
                },
                desc: "reserved"
            },
        ]
    },
    {
        offset: 0xFA,
        len: T_BYTE,
        default: 0xEF,
        description: "Config bitmap 2 (EEPROM address: 0xFA)",
        section_description: "",
        proc: "bitfield",
        bits: [{
                bitsNumber: [0],
                values: {
                    0: "multimeter",
                    1: "clamp meter"
                },
                desc: "device type"
            },
            {
                bitsNumber: [1],
                values: {
                    0: "Function unavailable",
                    1: "REL key can turn on RS232 via long press"
                },
                desc: "RS232"
            },
            {
                bitsNumber: [2],
                values: {
                    0: "Function unavailable",
                    1: "HOLD key can turn on backlight via long press"
                },
                desc: "backlight"
            },
            {
                bitsNumber: [4, 3],
                values: {
                    0: "when backlight is on PT2.2=0; when off PT2.2=1",
                    1: "when backlight is on PT2.2=1; when off PT2.2=0",
                    2: "when backlight is on PT2.2=PWM, PT2.3=0; when off PT2.2=1, PT2.3=1",
                    3: "when backlight is on PT2.2=PWM, PT2.3=1; when off PT2.2=1, PT2.3=0"
                },
                desc: "Backlight mode. (when backlight is in on/off mode, PT2.3 is used for low voltage detection. When backlight is in PWM mode, PT2.3 is used as the backlight switch)"
            },
            {
                bitsNumber: [6],
                values: {
                    0: '?',
                    1: 'default'
                },
                desc: "reserved"
            },
            {
                bitsNumber: [7],
                values: {
                    0: "mV range is 200mV",
                    1: "mV ranges are 20mV/200mV"
                },
                desc: "mV ranges"
            },
        ]
    },
    {
        offset: 0xFB,
        len: T_BYTE,
        default: 0x0F,
        description: "Auto power off time [m]  (EEPROM address: 0xFB)",
        proc: "num",
        section_description: "Auto power off time in minutes. Set to 0 to disable the auto power-off functionality - the meter will never turn off by itself. <strong>Hint</strong>: you can disable this function temporarily by holding the SELECT key when powering on the meter."
    },
    {
        offset: 0xFC,
        len: T_BYTE,
        default: 0x0F,
        description: "Backlight auto power-off timer [s] (EEPROM address: 0xFC)",
        proc: "num",
        section_description: "Backlight auto power-off timer in seconds. Set to 0 to disable the auto power-off of backlight functionality - the backlight has to be turned off manually."
    },
    {
        offset: 0xFD,
        len: T_BYTE,
        default: 0x80,
        description: "Config bitmap 3 (EEPROM address: 0xFD)",
        section_description: "",
        proc: "bitfield",
        bits: [{
                bitsNumber: [3, 2, 1, 0],
                values: {
                    2: "2s",
                    15: "15s"
                },
                desc: "Low voltage power off delay (seconds)"
            },
            {
                bitsNumber: [4],
                values: {
                    0: "PT1.2 used for NCV LED and power LED",
                    1: "PT1.2 used for NCV LED only"
                },
                desc: "PT1.2 output mode"
            },
            {
                bitsNumber: [5],
                values: {
                    0: "UART uses 15 bytes format (seg0~seg14)",
                    1: "UART uses 14 bytes format (seg0~seg13)"
                },
                desc: "UART format"
            },
            {
                bitsNumber: [6],
                values: {
                    0: 'UART format bit3~bit0 → com3~com0',
                    1: 'UART format bit3~bit0 → com0~com3'
                },
                desc: "UART order"
            },
            {
                bitsNumber: [7],
                values: {
                    0: 'Frequency range fixed Pt3.6',
                    1: 'Frequency range switchable. Pt3.6 & RLD'
                },
                desc: "Frequency range mode"
            },
        ]
    },	
	
	
    // 0xFE..0xFF - unknown
];

const measurement_modes = new Map([
    {value: 0x00, description: "No function"},
    {value: 0x01, description: "DC mV, (20mV/200mV)"},
    {value: 0x02, description: "AC mV, (20mV/200mV)"},
    {value: 0x03, description: "DC V, (no mV range) 2V/20V/200V/2000V"},
    {value: 0x04, description: "AC V, (no mV range) 2V/20V/200V/2000V"},
    {value: 0x05, description: "DC V, 200mV/2V/20V/200V/2000V"},
    {value: 0x06, description: "AC V, 200mV/2V/20V/200V/2000V"},
    {value: 0x07, description: "Resistance 200Ω/2kΩ/20kΩ/200kΩ/2MΩ/20MΩ/200MΩ"},
    {value: 0x08, description: "reserved"},
    {value: 0x09, description: "Continuity"},
    {value: 0x0A, description: "Diode"},
    {value: 0x0B, description: "Capacitance 9.999nF/99.99nF/999.9nF/9.999μF/99.99μF/999.9μF/9.999mF/99.99mF"},
    {value: 0x0C, description: "DC μA, 200μA/2000μA"},
    {value: 0x0D, description: "AC μA, 200μA/2000μA"},
    {value: 0x0E, description: "DC mA, 20mA/200mA"},
    {value: 0x0F, description: "AC mA, 20mA/200mA"},
    {value: 0x10, description: "DC A, 2A/20A"},
    {value: 0x11, description: "AC A, 2A/20A"},
    {value: 0x12, description: "Frequency (Hz) / Duty"},
    {value: 0x13, description: "Temperature (°C)"},
    {value: 0x14, description: "Transistor hFe"},
    {value: 0x15, description: "Temperature (°F)"},
    {value: 0x16, description: "DC A, 2A"},
    {value: 0x17, description: "AC A, 2A"},
    {value: 0x18, description: "DC A, 20A"},
    {value: 0x19, description: "AC A, 20A"},
    {value: 0x1A, description: "DC A, 200A"},
    {value: 0x1B, description: "AC A, 200A"},
    {value: 0x1C, description: "DC A, 2000A"},
    {value: 0x1D, description: "AC A, 2000A"},
    {value: 0x1E, description: "Non-contact Voltage (NCV)"},
].map(e=>[e.value,e.description]));

const modeToDialPosition = new Map([
    [0x03, ["NCV"]],
	[0x05, ["AUTO RANGE uA~/⎓"]],
	[0x06, ["AUTO RANGE A~/⎓"]],
	[0x07, ["AUTO RANGE V⎓"]],
    [0x0A, ["AUTO RANGE mA~/⎓"]],
    [0x0B, ["Ω (Alt: Ω, continuity, diode, capacitance)"]],
	[0x0D, ["Hz/%"]],
	[0x0E, ["AUTO RANGE V~"]],
	[0x0E, ["AUTO RANGE V AC"]],
    [0x0F, ["AUTO RANGE mV~/⎓ (Alt: mv⎓, mV~, °C, °F) "]],

]);

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------

class TheDump {
    /**
     * Initialize the dump from the data. Create and hold the copy of `data`.
     * @param {ArrayBuffer} data
     */
    constructor(data) {
        this.original_data = new Uint8Array(data.slice(0));
        this.data = new Uint8Array(data.slice(0));
        this.listeners = new Map(); // offset -> callback
    }

    /**
     * Call all unique registered observers for the given offsets.
     * @param {number[]} offsets
     * @param {number} newValue
     */
    callObserversFor(offsets, newValue) {
        // TODO: do we need also the old value?

        // Get all unique listeners
        const unique_listeners = new Set();
        for (const offset of offsets) {
            for (const listener of this.listeners.get(offset) || []) {
                unique_listeners.add(listener);
            }
        }

        // Run the listeners
        for (const listener of unique_listeners) {
            console.log("Running listener for " + offsets, listener, newValue);
            listener(offsets, newValue);
        }
    }

    /**
     * Modify a byte at a given offset in the dump
     * @param {number} offset
     * @param {number} value
     */
    modifyByte(offset, value) {
        this.data[offset] = value;
        this.callObserversFor([offset], value);
    }

    /**
     * Modify a word (little-endian) at a given offset in the dump
     * @param {number} offset
     * @param {number} value
     */
    modifyWord(offset, value) {
        offset = +offset;
        value = +value;

        const lowByte = value & 0xFF;
        const hiByte = (value>>8) & 0xFF;
        this.data[offset] = lowByte;
        this.data[offset+1] = hiByte;

        this.callObserversFor([offset, offset+1], value);
    }

    /**
     * Get the original data of length `length` from the offset `offset`
     * @param {number} offset
     * @param {number} length Only lengths of 1 and 2 are supported
     */
    getOriginal(offset, length) {
        if (length == 1) return this.getOriginalByte(offset);
        else if (length == 2) return this.getOriginalWord(offset);
        else throw new Error("Unsupported length");
    }

    /**
     * Get the original (not modified) byte from the offset `offset`
     * @param {number} offset
     */
    getOriginalByte(offset) { return this.original_data[offset]; }

    /**
     * Get the original (not modified) word (little-endian) from the offset `offset`
     * @param {number} offset
     */
    getOriginalWord(offset) { offset = +offset; return (this.original_data[offset+1]<<8)|this.original_data[offset]; }

    /**
     * Get the (modified) data of length `length` from the offset `offset`
     * @param {number} offset
     * @param {number} length Only lengths of 1 and 2 are supported
     */
    get(offset, length) {
        if (length == 1) return this.getByte(offset);
        else if (length == 2) return this.getWord(offset);
        else throw new Error("Unsupported length");
    }

    /**
     * Get the (modified) byte from the offset `offset`
     * @param {number} offset
     */
    getByte(offset) { return this.data[offset]; }

    /**
     * Get the (modified) word (little-endian) from the offset `offset`
     * @param {number} offset
     */
    getWord(offset) { offset = +offset; return (this.data[offset+1]<<8)|this.data[offset]; }

    /**
     * Register the `observer` to be called every time any of the `nBytes` starting at `startOffset` changes
     * @param {number} startOffset
     * @param {number} nBytes
     * @param {function} observer
     */
    observe(startOffset, nBytes, observer) {
        for(let offset=startOffset; offset<startOffset+nBytes; ++offset) {
            if (this.listeners.has(offset)) {
                this.listeners.get(offset).push(observer);
            } else {
                // TODO: how about sets not lists?
                this.listeners.set(offset, [observer]);
            }
        }
    }

    /**
     * Register the `observer` to be called every time a byte at the `offset` changes
     * @param {number} offset
     * @param {function} observer
     */
    observeByte(offset, observer) { return this.observe(offset, 1, observer); }

    /**
     * Register the `observer` to be called every time a word at the `offset` changes
     * @param {number} offset
     * @param {function} observer
     */
    observeWord(offset, observer) { return this.observe(offset, 2, observer); }

    /**
     * Returns the blob of type "octet/stream" representing the current (possibly modified) dump
     * @returns {Blob}
     */
    get blob() { return new Blob([this.data], {type: "octet/stream"}) }
}


// ------------------------------------------------------------------------------------------------------------
// Define editor handlers

/**
 * Creates a standard numeric editor
 * @param {object} rangeItem
 */
function numEditor(rangeItem) {
    let elNumEditorContainer = document.createElement('div');

    let elEditor;
    if (rangeItem.len == T_BYTE) {
        elEditor = createHexEdit(theDump, T_BYTE, rangeItem.offset);
    } else if (rangeItem.len == T_WORD) {
        elEditor = createHexEdit(theDump, T_WORD, rangeItem.offset);
    } else {
        console.log("ERROR: unknown length in range", rangeItem);
        elNumEditorContainer.textContent = "ERROR: unknown length";
        return;
    }
    elNumEditorContainer.appendChild(elEditor);

    const elValueVisualizer = document.createElement('div');
    elValueVisualizer.classList.add('value_visualizer');

    // hex/dec visualizers
    elEditor.addEventListener('keyup', e=>{
        const value = +e.target.value;
        elValueVisualizer.textContent = `Requested value: (dec) ${value}`;
//        elValueVisualizer.textContent = `Requested value: (hex) 0x${toHex(value, 2)}, (dec) ${value}`;
    });

    elNumEditorContainer.appendChild(elValueVisualizer);

    // Simulate a `keyup` event to update the component state
    elEditor.dispatchEvent(new KeyboardEvent('keyup'));

    return elNumEditorContainer;
};

// ------------------------------------------------------------------------------------------------------------

/**
 * Creates a standard bitfield editor
 * @param {object} rangeItem
 */
function bitfieldEditor(rangeItem) {
    const elBitfieldEditorContainer = document.createElement('div');
    const offset = rangeItem.offset;
    const byteValue = theDump.getByte(offset);

    for (const {bitsNumber, values, desc} of rangeItem.bits) {
        const elFieldSection = document.createElement('div');
        const bitText = bitsNumber.join(", ");

        elFieldSection.classList.add('bitfield');

        {
            // Add a description for the current bitfield
            const elBitfieldDescription = document.createElement('div');
            elBitfieldDescription.classList.add('bitfield_description');
            elBitfieldDescription.innerHTML = `Bits: ${bitText} | ${desc}`;
            elFieldSection.appendChild(elBitfieldDescription);
        }

        // Extract bits for the current bitfield and create a number representing those bits
        let currentValue = 0;
        for (const iBit of bitsNumber) {
            currentValue <<= 1;
            currentValue |= (byteValue>>iBit)&1;
        }

        // Create a select element with allowed values
        const elBitList = document.createElement('select');
        elBitList.id = `bitfield_offset_${offset}_bits_${bitsNumber.join(',')}`;
        elBitList.setAttribute('data-dump-offset', offset);
        elBitList.data_bits = bitsNumber;

        for (const bitValue in values) {
            const valueDescription = values[bitValue];

            const elOption = document.createElement('option');
            elOption.value = bitValue;

            if (+bitValue == currentValue) {
                // Select the option corresponding to the current value of the bitfield
                elOption.setAttribute('selected', 'selected');
            }

            elOption.innerText = `0x${toHex(+bitValue, 2)}: ${valueDescription}`;
            elBitList.appendChild(elOption);
        }

        // Update the bitfield on change (the whole byte gets updated)
        elBitList.addEventListener('change', e=>{
            const elTarget = e.target;
            const bitmask = elTarget.data_bits.map(e=>1<<e).reduce((e,r)=>r|=e);
            const offsetInDump = +elTarget.getAttribute('data-dump-offset');
            let byteValue = theDump.getByte(offset); // new Uint8Array(modifiedDump.slice(offset, offset+1))[0];

            // Clear target bitfield
            byteValue &= ~bitmask;

            // Set values
            let valueToSet = +elTarget.selectedOptions[0].value;
            for(const iBit of elTarget.data_bits.slice().reverse()) {
                const bitValue = valueToSet&1;
                byteValue |= bitValue<<iBit;
                valueToSet>>=1;
            }

            changeInDumpByte(offsetInDump, byteValue);
        });

        elFieldSection.appendChild(elBitList);
        elFieldSection.appendChild(document.createElement('hr'));
        elBitfieldEditorContainer.appendChild(elFieldSection);
    }

    return elBitfieldEditorContainer;
}

// ------------------------------------------------------------------------------------------------------------

/**
 * Creates a custom calibration editor
 * @param {object} rangeItem
 */
function calEditor(rangeItem) {
    // Create the editor for calibration
    const elCalEditorContainer = document.createElement('div');

    const elCalRangeList = document.createElement('ul');
    elCalEditorContainer.appendChild(elCalRangeList);

    // Create and edit field and a label for that field and encapsulate it in a list item
    const addEditField = (startOffset, labelText) => {
        const elEditor = createHexEdit(theDump, T_WORD, startOffset);
        const elLabel = document.createElement('span');
        elLabel.textContent = labelText;
        const elListItem = document.createElement('li');
        elListItem.appendChild(elLabel);
        elListItem.appendChild(elEditor);
        elCalRangeList.appendChild(elListItem)
        return [elListItem, elEditor];
    };

    // For each available A range
    for (let [calRange, offset] of [["2A", 0], ["20A", 2], ["200A",4], ["2000A",6]]) {
        const [eListItem, eEditor] = addEditField(rangeItem.offset+offset, `For ${calRange} (correction): `);
        {
            // Add en editor for correction factor (as a floating point number)
            const elCorrectionFactorEditor = document.createElement('input');
            const correctionFactor = +eEditor.value / 0x8000;
            elCorrectionFactorEditor.type = "text";
            elCorrectionFactorEditor.id = `hexedit_correction_factor_${offset}`
            elCorrectionFactorEditor.value = `${correctionFactor}`;
            elCorrectionFactorEditor.defaultValue = elCorrectionFactorEditor.value;

            // On every change - check for validity update the hex representation
            // Also - fire all needed events on the updated hex field
            elCorrectionFactorEditor.addEventListener('change', e=>{
                const elTargetElement = e.target;
                const value = +elTargetElement.value;
                const hexFactor = value * 0x8000;
                if (value < 0 || value > 1.99996) {
                    alert(`Value ${value} out of range: 0-1.99996.\n` +
                          `Reverting to the previous value.`);
                    elTargetElement.value = elTargetElement.defaultValue;
                    elTargetElement.dispatchEvent(new KeyboardEvent('keyup'));
                    return false;
                }

                eEditor.value = `0x${toHex(Math.round(hexFactor), 4)}`;
                eEditor.dispatchEvent(new KeyboardEvent('keyup'));
                eEditor.dispatchEvent(new KeyboardEvent('change'));
                elCorrectionFactorEditor.defaultValue = elCorrectionFactorEditor.value;
            });

            // If the hex value changes - update the numeric representation
            eListItem.addEventListener('change', e=>{
                elCorrectionFactorEditor.value = +eEditor.value / 0x8000;
            });

            // Append the numeric representation editor
            eListItem.appendChild(elCorrectionFactorEditor);
        }

        {
            // Create and add value visualizer: show both dec, hex and computed floating point value
            const elValueVisualizer = document.createElement('div');
            elValueVisualizer.classList.add('value_visualizer');

            // hex/dec visualizers + correction factor (float)
            eEditor.addEventListener('keyup', e=>{
                const value = +e.target.value;
                const correctionFactor = value / 0x8000;
				elValueVisualizer.textContent = `Requested value: (dec) ${value} => correction factor of ${correctionFactor}`;
//                elValueVisualizer.textContent = `Requested value: (hex) 0x${toHex(value, 4)}, (dec) ${value} => correction factor of ${correctionFactor}`;
            });

            eListItem.appendChild(elValueVisualizer);
            eEditor.dispatchEvent(new KeyboardEvent('keyup'));
        }

        addEditField(rangeItem.offset+offset+8, `For ${calRange} (zero): `);
    }

    return elCalEditorContainer;
};

// ------------------------------------------------------------------------------------------------------------

/**
 * Creates a custom device mode editor
 * @param {object} rangeItem
 */
function modesEditor(rangeItem) {
    const elModeEditorContainer = document.createElement('div');

    const modesSetupData = new Uint8Array(
        theDump.data.slice(rangeItem.offset, rangeItem.offset+rangeItem.len)
    );

    const nModes = modesSetupData.length / 4;

    {
        // Add a checkbox to toggle visibility of unused modes (indicated by data-unused-mode)
        const elHideUnusedLabel = document.createElement('label');
        elHideUnusedLabel.setAttribute("for", "hide_unused_modes")
        elHideUnusedLabel.textContent = "Hide unused modes";

        const elHideUnusedCheckbox = document.createElement('input');
        elHideUnusedCheckbox.type = 'checkbox';
        elHideUnusedCheckbox.id = 'hide_unused_modes';
        elHideUnusedCheckbox.checked = true;

        // On click: toggle the visibility of unused editors
        elHideUnusedCheckbox.addEventListener('click', e=>{
            const shouldHide = e.target.checked;
            if (shouldHide) {
                document.querySelectorAll('.meterModes .mode').forEach(e=>{
                    if (e.getAttribute('data-unused-mode') == "true") {
                        e.classList.add('unused');
                    }
                });
            } else {
                document.querySelectorAll('.meterModes .unused').forEach(e=>{
                    e.classList.remove('unused');
                });
            }

        });

        // Add the label and the checkbox
        elModeEditorContainer.append(elHideUnusedLabel);
        elModeEditorContainer.append(elHideUnusedCheckbox);
    }

    const elMeterModes = document.createElement('div')
    elMeterModes.classList.add("meterModes");

    // For each mode supported by the chipset (a subset of those might be supported by the device)
    for (let iMeterMode = 0; iMeterMode < nModes; ++iMeterMode) {
        const elCurrentMeterMode = document.createElement('div');
        elCurrentMeterMode.classList.add("mode");

        const dialInfo = modeToDialPosition.get(iMeterMode);
        const dumpOffset = rangeItem.offset + iMeterMode;

        // Create a mode description (as HTML). If the mode is unused - indicate that.
        let dialInfoHtml;
        if(dialInfo) {
            dialInfoHtml = dialInfo[0];
        } else {
            elCurrentMeterMode.classList.add('unused');
            elCurrentMeterMode.setAttribute('data-unused-mode', 'true');
            dialInfoHtml = "unused";
        }

        // Add the mode description
        elCurrentMeterMode.innerHTML = `Mode 0x${toHex(iMeterMode, 2)} (ZT219/AN870 dial position: ${dialInfoHtml}): <br>`;

        // For each sub-mode of the current mode: add a list of all available modes
        // with the currently set mode selected
        const elModeSubModes = document.createElement('ol');
        for (let variantOffset of [0x00, 0x10, 0x20, 0x30]) {
            const elListItem = document.createElement('li');
            const elSubMode = createSelectMode(modesSetupData[iMeterMode+variantOffset], dumpOffset+variantOffset);
            elListItem.appendChild(elSubMode);
            elModeSubModes.appendChild(elListItem);
        }

        // Add all sub-modes to the current mode
        elCurrentMeterMode.appendChild(elModeSubModes);

        // Add the current mode to the list of all modes
        elMeterModes.appendChild(elCurrentMeterMode);
    }

    // Add the complete multimeter modes editor
    elModeEditorContainer.appendChild(elMeterModes)

    return elModeEditorContainer;
};

// ------------------------------------------------------------------------------------------------------------

const elLogBox = document.getElementById('logs');
const elOriginalHexDumpField = document.getElementById('original_hex_dump');
const elModifiedHexDumpField = document.getElementById('modified_hex_dump');
const elEditorContainer = document.getElementById('editor_container');
const elGetModifiedBumpBtn = document.getElementById('get_modified_dump');
const elLoadEEPROMButton = document.getElementById('btnLoadEEPROM');

let originalEEPROM_FileName = '';
let theDump;

/**
 * Add a line with text `s` to the user log.
 * @param {string} s Text to be appended to the user log
 */
function userLog(s) {
    const logLine = document.createElement('p');
    logLine.innerText = `LOG: ${s}`;
    elLogBox.appendChild(logLine);
}

/**
 * Read EEPROM from file. Asynchronously process the EEPROM after reading.
 * @param {Blob} file
 */
function readEEPROMFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const data = e.target.result;
        if (data instanceof ArrayBuffer) {
            userLog(`Data loaded: ${data.byteLength} bytes.`);
            processEEPROM(data);
        }
    };
    reader.readAsArrayBuffer(file);
}

/**
 * Return hex representation of the value `d` using exactly `len`
 * characters (add leading zeros if needed).
 * @param  {number} value
 * @param  {number} length
 */
function toHex(value, length) {
    return ("0".repeat(length-1) + value.toString(16).toUpperCase()).slice(-length);
}

/**
 * Generate the interactive hex dump.
 * @param {Uint8Array} dataBytes Data bytes to be displayed
 * @param {Uint8Array} [originalDataBytes] Original data used to indicate which bytes changed
 */
function getHexDumpText(dataBytes, originalDataBytes) {
    // Color definition
    const unassigned_color = "#EEEEEE";

    const colors = [
        "#ff8a6566",
        "#039be566",
        "#9933FF66",
        "#48c9b066",
        "#6600CC66",
        "#CCCC3366",
    ];

    // --------------------------------------------------------------------------------

    const nColumns = 0x10;
    const dataLength = dataBytes.byteLength;

    // for each range mark bytes within that range with a color (cyclic)
    const colorization = new Array(dataBytes.length).fill([unassigned_color, -1]);
    for(let i=0; i<bin_ranges.length; ++i) {
        const color = colors[i%colors.length];
        const currentRange = bin_ranges[i];
        const currentRangeStart = currentRange.offset;
        const currentRangeEnd = currentRangeStart+currentRange.len-1;
        for(let offset=currentRange.offset; offset<=currentRangeEnd; ++offset) {
            colorization[offset] = [color, i];
        }
    }

    let hexDump = "";

    // Add blank space where column and row labels meet
    hexDump += '<div class="column_row_common"></div>';

    // Generate column offsets
    hexDump += `<div class="column_offset">`;
    for(let i=0; i<nColumns-1; ++i) {
        hexDump += `${toHex(i, 2)} `;
        if (i % 4 ==3) hexDump += '  ';
    }
    hexDump += `${toHex(nColumns-1, 2)}`;
    hexDump += `</div>`;

    // Generate row offsets
    hexDump += `<div class="row_offset">`;
    const nRows = dataLength/nColumns;
    for(let i=0; i<nRows; ++i) {
        hexDump += `${toHex(i*nColumns, 2)}\n`;
    }
    hexDump += `</div>`;

    // Generate the actual hex dump with coloring and interactivity
    hexDump += `<div class="dump_content">`;
    let prev_color = "";
    for(let i=0; i<dataLength; ++i) {
        const isModified = originalDataBytes && (originalDataBytes[i] != dataBytes[i]);
        const [currentColor, rangeIndex] = colorization[i];

        // Join all adjacent fields with the same color
        if (prev_color != currentColor) {
            if (i>0) hexDump += '</span>';
            const class2 = (currentColor == unassigned_color)?" unused":"";
            hexDump += `<span class="hexrange${class2}" style="background-color:${currentColor}" data-range-index="${rangeIndex}">`;
            prev_color = currentColor;
        }

        // Indicate all modified bytes
        if (isModified) hexDump += '<span class="modified">';
        hexDump += toHex(dataBytes[i], 2);
        if (isModified) hexDump += '</span>';

        // Break line or introduce intra-line separators (after each 4 bytes)
        if (i%nColumns == nColumns-1) hexDump += "<br/>";
        else if (i%8 == 7) hexDump += "   ";
        else if (i%4 == 3) hexDump += " - ";
        else hexDump += " ";
    }
    hexDump += '</span>';
    hexDump += `</div>`;

    // Fix the dump: remove all trailing spaces from inner tags to avoid having colorized empty spaces
    hexDump = hexDump.replace(/([\s-]+)<\/span>/gm, `</span>$1`);

    // Parse created HTML to enable DOM-level manipulations
    const elHexContainer = document.createElement('div');
    elHexContainer.classList.add('hex_container_grid');
    elHexContainer.innerHTML = hexDump;

    // Extract fields from the "Hex Hover" element
    const elHexHover = document.querySelector('#hexhover');
    const elHexHoverDescription = elHexHover.querySelector('.range_description');
    const elHexHoverOffsetValue = elHexHover.querySelector('.offset_value');
    const elHexHoverOrgValue = elHexHover.querySelector('.org_value');
    const elHexHoverCurValue = elHexHover.querySelector('.cur_value');

    // Define function to show/hide/update "Hex Over" tooltips
    const xHexoverOffset = 10;
    const yHexoverOffset = 10;
    const updatePosition = e => {
        let desiredLeft = e.x + xHexoverOffset;
        let desiredTop = e.y + yHexoverOffset;

        // Only on supported browsers: make sure the tooltip looks good
        // near the edges of the viewport
        if(window.visualViewport) {
            // Don't move too close to the right viewport edge
            if (desiredLeft + elHexHover.fullWidth + xHexoverOffset > window.visualViewport.width) {
                desiredLeft = window.visualViewport.width - elHexHover.fullWidth - xHexoverOffset;
            }

            // If we are too close to the bottom viewport edge, move the tooltip
            // to be above the mouse cursor
            if (desiredTop + elHexHover.fullHeight > window.visualViewport.height) {
                desiredTop = e.pageY - elHexHover.fullHeight - 1;
            }
        }

        elHexHover.style.top = `${desiredTop}px`;
        elHexHover.style.left = `${desiredLeft}px`;
    };

    // Function for: every time mouse enters one of the ranges, update the "Hex Over" tooltip
    const onMouseEnter = e => {
        const target = e.target;

        // Process only ranges with defined range_index (i.e. with entries in `bin_ranges`)
        const rangeIndex = +target.getAttribute("data-range-index");
        if (rangeIndex == -1) return;

        // Fill the description, offset and length based on the bin_ranges
        const currentRange = bin_ranges[rangeIndex];
        const desc = currentRange.description;
        const offset = currentRange.offset;
        const length = currentRange.len;
        elHexHoverDescription.textContent = desc;
        elHexHoverOffsetValue.textContent = `0x${toHex(offset, 2)}`;

        // Show current/old values only on fields shorter or equal than 2 bytes
        if (length <= 2) {
            const orgValue = theDump.getOriginal(offset, length);
            const curVale = theDump.get(offset, length);
            elHexHoverOrgValue.textContent = `0x${toHex(orgValue, length*2)} (${orgValue})`;
            elHexHoverCurValue.textContent = `0x${toHex(curVale, length*2)} (${curVale})`;
            if (orgValue != curVale) {
                elHexHoverCurValue.style.color = 'red';
            } else {
                elHexHoverCurValue.style.color = '';
            }
        } else {
            elHexHoverOrgValue.textContent = '(see editor)';
            elHexHoverCurValue.textContent = '(see editor)';
        }

        // Get the size of the tooltip and store it in the element properties: fullWidth, fullHeight
        elHexHover.style.visibility = 'hidden';
        elHexHover.style.top = `0px`;
        elHexHover.style.left = `0px`;
        elHexHover.style.display = 'block';
        const boxSize = elHexHover.getBoundingClientRect();
        elHexHover.fullWidth = boxSize.width;
        elHexHover.fullHeight = boxSize.height;

        // Set the position of the tooltip to be around the mouse pointer
        updatePosition(e);

        // Show the tooltip
        elHexHover.style.visibility = '';
    };

    // Function for: on each mouse move update the position of the tooltip
    const onMouseMove = e => {
        updatePosition(e);
    };

    // Function for: hide the tooltip every time the mouse leaves the range
    const onMouseLeave = e => {
        const target = e.target;
        const rangeIndex = +target.getAttribute("data-range-index");
        elHexHover.style.display = 'none';
    };

    // Function for: when the user clicks on the range, scroll the editor to
    // the appropriate section
    const onClick = e => {
        const target = e.currentTarget;
        const rangeIndex = +target.getAttribute("data-range-index");
        if (rangeIndex == -1) return;
        const currentRange = bin_ranges[rangeIndex];
        currentRange.eEditor.querySelector('h3').scrollIntoView({
            block: 'center'
        });

        visuallyBlink(currentRange.eEditor);
    };

    // Register all events for all the ranges
    for(const range of elHexContainer.querySelectorAll('.hexrange')) {
        range.addEventListener('mouseenter', onMouseEnter);
        range.addEventListener('mousemove', onMouseMove);
        range.addEventListener('mouseleave', onMouseLeave);
        range.addEventListener('click', onClick);
    }

    // Return a container for the hex editor as a DOM node with
    // all event handlers attached
    return elHexContainer;
}

/**
 * Create the `select` element for `i`-th multimeter mode
 * @param {number} selectedModeNumber Mode number selected by default
 * @param {number} offset Offset in the hex dump for the `i`-th mode
 */
function createSelectMode(selectedModeNumber, offset) {
    const elModeList = document.createElement('select');
    elModeList.id = `mode_offset_${offset}`
    elModeList.setAttribute('data-dump-offset', `${offset}`);

    // Create an option for each possible mode
    for (const [iMode, modeDescription] of measurement_modes) {
        const elOption = document.createElement('option');
        elOption.value = `${iMode}`;
        if (selectedModeNumber == iMode) elOption.setAttribute('selected', 'selected');
        elOption.innerText = `0x${toHex(iMode,2)}: ${modeDescription}`;
        elModeList.appendChild(elOption);
    }

    // On option change: update the value in the dump
    elModeList.addEventListener('change', e=>{
        const targetElement = e.target;
        changeInDumpByte(
            +targetElement.getAttribute('data-dump-offset'),
            +targetElement.selectedOptions[0].value
        );
    });

    // Return the select element as a DOM element
    return elModeList;
}


/**
 * @param {TheDump} dump The dump object
 * @param {number} nBytes Length of number, in bytes
 * @param {number} offset Offset in the dump where the value is stored
 */
function createHexEdit(dump, nBytes, offset) {
    // Generalized element creation function
    const typeHandler = (value, maxVal, changer) => {
        const elInputField = document.createElement('input');
        elInputField.type = "text";
        elInputField.id = `hexedit_offset_${offset}`
        elInputField.setAttribute('data-dump-offset', `${offset}`);
        elInputField.value = `0x${toHex(value, nBytes*2)}`;
        elInputField.defaultValue = elInputField.value;

        // Update the value in the dump after change. Check if the value is valid.
        elInputField.addEventListener('change', e=>{
            const targetElement = e.target;
            const value = parseInt(targetElement.value);
            if (value < 0 || value > maxVal) {
                alert(`Value ${value} (0x${toHex(value, nBytes*2)}) out of range: 0-${maxVal}` +
                      `(0x00 - 0x${toHex(maxVal, nBytes*2)}).\n` +
                      `Reverting to the previous value.`);
                targetElement.value = targetElement.defaultValue;
                targetElement.dispatchEvent(new KeyboardEvent('keyup'));
                return false;
            }
            changer(+targetElement.getAttribute('data-dump-offset'), value);
            elInputField.defaultValue = elInputField.value;
        });
        return elInputField;
    };

    let inputField;
    if (nBytes == T_BYTE) {
        const value = dump.getByte(offset);
        inputField = typeHandler(value, 0xFF, changeInDumpByte);
    } else if (nBytes == T_WORD) {
        const value = dump.getWord(offset);
        inputField = typeHandler(value, 0xFFFF, changeInDumpWord);
    } else {
        inputField.value = "UNKNOWN TYPE"
    }
    return inputField;
}

/**
 * Change specified byte in the dump
 * @param {number} offset
 * @param {number} newValue
 */
function changeInDumpByte(offset, newValue) {
    userLog(`Changing WORD in dump @offset[0x${toHex(offset,4)}] := ${newValue} (0x${toHex(newValue, 2)})`);
    theDump.modifyByte(offset, newValue);
    elModifiedHexDumpField.textContent = '';
    elModifiedHexDumpField.appendChild(getHexDumpText(theDump.data, theDump.original_data));
}

/**
 * Change specified word (little-endian) in the dump
 * @param {number} offset
 * @param {number} newValue
 */
function changeInDumpWord(offset, newValue) {
    userLog(`Changing WORD in dump @offset[0x${toHex(offset,4)}] := ${newValue} (0x${toHex(newValue, 4)})`);
    theDump.modifyWord(offset, newValue);
    elModifiedHexDumpField.textContent = '';
    elModifiedHexDumpField.appendChild(getHexDumpText(theDump.data, theDump.original_data));
}

/**
 * Blink the specified element using CSS class
 * @param {Element} e Element
 */
function visuallyBlink(e) {
    e.classList.add('blink_three_times');

    let blinkClassRemove = e.addEventListener('animationend', ()=>{
        e.classList.remove('blink_three_times');
        e.removeEventListener('animationend', blinkClassRemove);
    });
}

/**
 * Process the EEPROM data. Create hex dump viewers and the editor.
 * @param {ArrayBuffer} data EEPROM data
 */
function processEEPROM(data) {
    // Check if the size if the data is OK
    if (data.byteLength != EEPROM_size) {
        alert(`EEPROM not loaded.\nIncorrect EEPROM size: ${data.byteLength} bytes.\nThe EEPROM should have ${EEPROM_size} bytes.`)
        return false;
    }

    // Create the dump object
    theDump = new TheDump(data);

    // Clear and create both hex dump viewers (original and modified)
    elOriginalHexDumpField.textContent = '';
    elOriginalHexDumpField.appendChild(getHexDumpText(theDump.data));

    elModifiedHexDumpField.textContent = '';
    elModifiedHexDumpField.appendChild(getHexDumpText(theDump.data, theDump.original_data));

    // Clear and create the dump editor
    elEditorContainer.textContent = '';
    const elEditors = document.createElement('div');
    elEditors.id = 'editors';

    // Add an editor for each of the supported ranges
    const supportedEditors = new Map([
        ["num", numEditor],
        ["cal", calEditor],
        ["func", modesEditor],
        ["bitfield", bitfieldEditor],
    ]);

    for (const bin_range of bin_ranges) {
        const elEditableItem = document.createElement('p');

        {
            // Crate section header
            const elSectionHeader = document.createElement('h3');
            elSectionHeader.textContent = bin_range.description;
            elEditableItem.append(elSectionHeader);
        }

        {
            // Add section description
            const sectionDescription = document.createElement('div');
            sectionDescription.classList.add('section_description');
            sectionDescription.innerHTML = bin_range.section_description
            if (bin_range.default) {
				sectionDescription.innerHTML += ` Original value: (dec) ${bin_range.default}`;
//				sectionDescription.innerHTML += ` Original value: (dec) ${bin_range.default}, (hex) 0x${toHex(bin_range.default, 4)}`;
            }
            elEditableItem.appendChild(sectionDescription);
        }

        const editorCreator = supportedEditors.get(bin_range.proc);
        const rangeEditor = editorCreator(bin_range);
        elEditableItem.appendChild(rangeEditor);

        bin_range.eEditor = elEditableItem;
        elEditors.appendChild(elEditableItem);
    }
    elEditorContainer.appendChild(elEditors);
}

{
    elLoadEEPROMButton.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return false;

        userLog(`Processing file: ${file.name}`)
        readEEPROMFile(file);

        originalEEPROM_FileName = file.name;

        // Enable button to download (modified) EEPROM
        elGetModifiedBumpBtn.disabled = false;
    });

    elGetModifiedBumpBtn.addEventListener('click', e => {
        if(!originalEEPROM_FileName) {
            alert("Please load the EEPROM dump first.")
            return false;
        }

        const dataUrl = window.URL.createObjectURL(theDump.blob);
        const dataLink = document.createElement('a');
        dataLink.href = dataUrl;
        dataLink.download = `${originalEEPROM_FileName.slice(0, originalEEPROM_FileName.lastIndexOf('.'))}_modified.bin`;
        dataLink.click();

        // We can safely revoke the URL now.
        // "Requests that were started before the url was revoked should still succeed."
        // https://w3c.github.io/FileAPI/#dfn-revokeObjectURL
        window.URL.revokeObjectURL(dataUrl);
    })
}
})();
    </script>
  </body>
</html>
